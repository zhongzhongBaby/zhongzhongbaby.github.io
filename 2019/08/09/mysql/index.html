<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>mysql | Hexo</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">mysql</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">mysql</h1><div class="post-meta"><a href="/2019/08/09/mysql/#comments" class="comment-count"></a><p><span class="date">Aug 09, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h3 id="mysql-相关"><a href="#mysql-相关" class="headerlink" title="mysql 相关"></a>mysql 相关</h3><a id="more"></a>


<ol>
<li><p><strong>sql执行顺序</strong><br><br>from…leftjoin . on… where…group by…聚合函数.. having(对分组进行筛选)…select…order by… limit… </p>
<br>
重点：原来order by作用于源表和生成的结果集  所以可以针对select 没有映射到的列进行排序，也可以针对select 映射到的列使用新的虚拟表的字段名进行排序。<br>
注意：<br>
where执行顺序是从左往右执行的，在数据量小的时候不用考虑，但数据量多的时候要考虑条件的先后顺序，此时应遵守一个原则：排除越多的条件放在第一个。
</li>
<li><p><strong>Join执行原理解析</strong><br><br><a href="https://blog.csdn.net/fanxing1964/article/details/81477515" target="_blank" rel="noopener">https://blog.csdn.net/fanxing1964/article/details/81477515</a><br><br>一个完整的SQL语句中会被拆分成多个子句，子句的执行过程中会产生虚拟表(vt)，但是结果只返回最后一张虚拟表。<br><br>它的执行顺序如下(SQL语句里第一个被执行的总是FROM子句)：<br></p>
</li>
</ol>
<p><strong>FROM</strong>:对左右两张表执行笛卡尔积，产生第一张表vt1。行数为n<em>m（n为左表的行数，m为右表的行数<br><br>*</em>ON<strong>:根据ON的条件逐行筛选vt1，将结果插入vt2中<br><br>**JOIN添加外部行</strong>:，如果指定了LEFT JOIN(LEFT OUTER JOIN)，则先遍历一遍左表的每一行，其中不在vt2的行会被插入到vt2，该行的剩余字段将被填充为NULL，形成vt3；如果指定了RIGHT JOIN也是同理。但如果指定的是INNER JOIN，则不会添加外部行，上述插入过程被忽略，vt2=vt3（所以INNER JOIN的过滤条件放在ON或WHERE里 执行结果是没有区别的，下文会细说）<br><br><strong>WHERE</strong>:对vt3进行条件过滤，满足条件的行被输出到vt4<br><br><strong>SELECT</strong>:取出vt4的指定字段到vt5<br><br><strong>一定要牢记on和where的区别  ：</strong> on是连接的时候进行筛选，没有连接成功的还是会添加外部行到结果集中，但是where是对结果集进行筛选，会对所有的结果集进行筛选。</p>
<ol start="3">
<li><p><strong>表连接join查询与where后使用子查询的性能分析</strong><br><a href="https://www.cnblogs.com/quyanhui/p/9994725.html" target="_blank" rel="noopener">https://www.cnblogs.com/quyanhui/p/9994725.html</a> <br><br>重点：left join 产生的笛卡尔积都会放在在内存中，后续的on where 过滤都是直接在内训中操作的。<br><br>而子查询产生的结果集不会在内存中有缓存，所以对于外表的每一条数据，要想知道是否否和条件，都要进行一次子查询，比如，子查询耗时0.1秒，外表有200行数据，理论上要耗时200*0.1=20秒。<br><br>以上也就是join查询优于子查询的主要原因，<br><br>解决子查询性能低下的方法有两个，<br><br>一个就是转化为left join <br><br>另一个就是为子查询的列添加索引<br></p>
</li>
<li><p><strong>关于excit和in</strong> <br><br>在外表大，内表小，外表中有索引的情况下，使用IN。<br><br>在外表小，内表大，内表中有索引的情况下，使用EXITS。<br></p>
</li>
</ol>
<ol start="5">
<li><p><strong>form a ,b与from a join b on</strong>:<br><br>二者都会生成笛卡尔积，如果是inner join on 和 a b where 没有区别，但是left join或者right join 对于where 和 on 是有区别的。因为涉及join添加外部行。<br>join与取得结果集同步进行数据刷选及过滤。where : 获得结果集之后，才进行数据刷选及过滤。<br>执行顺序：on在上游，where在中游，having在下游（having 筛选分组）。</p>
</li>
<li><p><strong>组内最大错误写法</strong> order by + group by <br><br>即使是有嵌套也是先执行group by 再执行order by 这也就是不能使用order by + group 取得组内最大值的原因<br>group  by是对表中原来的字段进行分组的***，而不是处理之后的数据。</p>
</li>
<li><p><strong>小表驱动大表</strong><br>类似于嵌套循环 ，总的操作次数是一样的，但是如果小的循环在外层，对于数据库连接来说就只连接5次，如果1000在外，则需要进行1000次数据库连接，从而浪费资源，增加消耗。这就是为什么要小表驱动大表。<br>MySQL 表关联的算法是 Nest Loop Join，是通过驱动表的结果集作为循环基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。<br>例: user表10000条数据，class表20条数据<br>select * from user u left join class c u.userid=c.userid<br>这样则需要用user表循环10000次才能查询出来，而如果用class表驱动user表则只需要循环20次就能查询出来<br>例：<br>select * from class c left join user u c.userid=u.userid<br>小结果集驱动大结果集<br>de.cel 在2012年总结说，不管是你，还是 MySQL，优化的目标是尽可能减少JOIN中Nested Loop的循环次数。<br>以此保证：永远用小结果集驱动大结果集（Important）！<br><br>in小exists大<br>对于exists 可以理解为将主查询的数据放入到子查询中做条件验证<br><br>对于nested loop 之后需要做进一步研究。</p>
</li>
<li><p><strong>STRAIGHT_JOIN</strong>  <br><br>以左边表作为驱动表，改进<strong>优化器</strong>对于联表查询的执行顺序， <br><br>mysql 有自己的优化器。根据优化器算法给出执行计划，但是不是所有的执行计划都是最优的。<br>select t1.* <br><br>from Table1 t1 <br><br>inner join Table2 t2 <br><br>on t1.CommonID = t2.CommonID <br><br>where t1.FilterID = 1 <br><br>t1不是驱动表的时候，无法使用t1的索引。 <br> </p>
</li>
<li><p>聚合函数count() 需要注意的点。<br><br>count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。</p>
</li>
</ol>
<p><br><br><br><br><br><br><br></p>
<h3 id="mysql复杂查询总结"><a href="#mysql复杂查询总结" class="headerlink" title="mysql复杂查询总结"></a>mysql复杂查询总结</h3><ol>
<li><p><strong>子查詢和父级查询</strong>关联的时候理解如下<br><br>where 中的子查询<br><br>select 中的子查询<br><br>子查询依赖于外部查询的情况<br><br>相当于再外部查询的结果上，添加子查询的结果，但是添加的前提是，针对父级查询的特定行对应的子查询结果只能是一行。<br><br>直观理解：子查询都是针对父级查询一行一行的丰富（select）或者筛选（where）<br><br>子查询的执行顺序：先有外部查询结果集，在把结果集依次和子查询条件进行对比，因为子查询结果不在内存中缓冲，所以子查询会增加IO次数，带来性能瓶颈。</p>
</li>
<li><p><strong>取出组内最大</strong>  <br><br>方法一:<br><br>select  *  from a left join b on a.filed=b.filed where b.createdate=(select max(createdate) from b where b.filed=a.filed)<br>不同通过order by + group by 取是因为不知道分组取数的原则是什么？<br>select max(createdate) from b where b.filed=a.filed 此处相当于 select max(createdate) from b  group b.filed<br><br>方法二：<br><br>通过group by 和left join 组合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	ph.* </span><br><span class="line">FROM</span><br><span class="line">	pos_history ph</span><br><span class="line">	RIGHT JOIN ( SELECT Max( create_date ) AS create_date, pos_number FROM pos_history GROUP BY pos_number ) ph2 ON ph.pos_number = ph2.pos_number </span><br><span class="line">	AND ph.create_date = ph2.create_date </span><br><span class="line">	) phresult</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>连接表查询更新</strong>（在想要更改某个表之前，需要先查询同一个表，并根据查询结果进行更改）<br><br>把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩； <br></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student_score  set score</span><br><span class="line">=</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">	AVG( score ) </span><br><span class="line">FROM</span><br><span class="line">	student_score </span><br><span class="line">WHERE</span><br><span class="line">	cid IN ( SELECT cid FROM course WHERE tid = ( SELECT tid FROM teacher WHERE NAME = &apos;t1&apos; ) ) </span><br><span class="line">	) </span><br><span class="line">WHERE</span><br><span class="line">	cid IN (</span><br><span class="line">SELECT</span><br><span class="line">	cid </span><br><span class="line">FROM</span><br><span class="line">	course </span><br><span class="line">WHERE</span><br><span class="line">	tid = ( SELECT tid FROM teacher WHERE NAME = &apos;t1&apos; )</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>You can’t specify target table ‘student_score’ for update in FROM clause<br>不能从一张表中查出数据然后再更改同一张表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student_score s</span><br><span class="line">INNER JOIN (</span><br><span class="line">/*a b 笛卡尔积  也可以直接把（select avg(score ..) 作为查询结果集常量的字段 */</span><br><span class="line">SELECT</span><br><span class="line">	a.cid,</span><br><span class="line">	b.score </span><br><span class="line">FROM</span><br><span class="line">	( SELECT cid FROM course WHERE tid = ( SELECT tid FROM teacher WHERE NAME = &apos;t1&apos; ) ) a,</span><br><span class="line">	(</span><br><span class="line">SELECT</span><br><span class="line">	AVG( score ) score </span><br><span class="line">FROM</span><br><span class="line">	student_score </span><br><span class="line">WHERE</span><br><span class="line">	cid IN ( SELECT cid FROM course WHERE tid = ( SELECT tid FROM teacher WHERE NAME = &apos;t1&apos; ) ) </span><br><span class="line">	) b </span><br><span class="line">	) c ON s.cid = c.cid </span><br><span class="line">	SET s.score = c.score</span><br></pre></td></tr></table></figure>

<p>即所有的set select 类型的更新，都可以转化为inner join set  后者再封装一层</p>
<ol start="4">
<li>查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名<br><br>select S# from SC where C# in (select C# from SC where S#=’1002’)<br>group by S# having count()=(select count() from SC where S#=’1002’);<br>思路  课程完全相同： 先搜索所有课程，然后根据studentid分组 统计每个人的课程数量。   关键词 in  count</li>
<li>insert select 类型<br>Insert SC select S#,’002’,(Select avg(score)<br>from SC where C#=’002’) from Student where S# not in (Select S# from SC where C#=’002’);</li>
<li>将不同行数据显示为同一行 <br>   通过临时表实现<br>按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示： 学生ID,,数据库,企业管理,英语,有效课程数,有效平均分<br>SELECT S# as 学生ID<br>,(SELECT score FROM SC WHERE SC.S#=t.S# AND C#=’004’) AS 数据库<br>,(SELECT score FROM SC WHERE SC.S#=t.S# AND C#=’001’) AS 企业管理<br>,(SELECT score FROM SC WHERE SC.S#=t.S# AND C#=’006’) AS 英语<br>,COUNT(*) AS 有效课程数, AVG(t.score) AS 平均成绩<br>FROM SC AS t<br>GROUP BY S#<br>ORDER BY avg(t.score)</li>
<li>查询排名 set @r:=0;  （递增更改的时候也可以使用变量）<br><br>SELECT student_score.*,(@r:=@r + 1) as sort<br>FROM student_score<br>ORDER BY score;</li>
<li><strong>组内取前</strong><br>in limit 报错 <br><br>This version of MySQL doesn’t yet support ‘LIMIT &amp; IN/ALL/ANY/SOME subquery’<br>mysql 解决办法</li>
</ol>
<ul>
<li>inner join  <br>   SELECT a.<em>,b.</em><br>FROM test_tb_grade  a<br>INNER JOIN (SELECT id FROM test_tb_grade  LIMIT 0,5) b<br>ON a.id = b.id  </li>
<li>再包装一层 SELECT * FROM test_tb_grade<br>WHERE id IN<br>(SELECT sc.id FROM (SELECT id FROM test_tb_grade LIMIT 0,5)AS sc);</li>
</ul>
<p>9.排序组合 直接order by 加不同字段</p>
<ol start="10">
<li>按照时间分组之后，存在时间不连续的时候，可以通过逻辑表来实现每天的数据都能返回</li>
<li>类似于续报班级的统计类型的sql 可以针对班级主体，先写特定班级的下续报学员，然后添加外层查询，将特定id指向外层数据id。另外在一对多的情况下要充分利用group_concat 函数，来变为一对一关系。再把返回数据进行处理即可。</li>
<li>多列去重 count（dictinct a,b）    例子：平行线统计班级在班人次 </li>
</ol>
<p><br><br><br><br><br><br><br></p>
<h3 id="Mysql常用函数"><a href="#Mysql常用函数" class="headerlink" title="Mysql常用函数 "></a>Mysql常用函数 <br></h3><p>1.find_in_set()<br>有个文章表里面有个type字段，它存储的是文章类型，有 1头条、2推荐、3热点、4图文等等 。type中以 1,3,4 的格式存储,查找所有type中有4的图文类型的文章</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from article where FIND_IN_SET(&apos;4&apos;,type)</span><br></pre></td></tr></table></figure>

<p>FIND_IN_SET(str,strlist)<br>在mysql中，有时我们在做数据库查询时，需要得到某字段中包含某个值的记录，但是它也不是用like能解决的，使用like可能查到我们不想要的记录，它比like更精准</p>
<p>2.concat （拼接字符串）<br>select concat (id, name, score) as info from tt2;   –&gt;1小明0 <br><br>concat_ws() 指定分隔符  concat_ws(separator, str1, str2, …)<br><br>group_concat()将group by产生的同一个分组中的值连接起来，返回一个字符串结果。<br>group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] )<br>group_concat 常和 find_in_set 一起使用</p>
<p>3.ifnull(tNumTb.num,0) 返回第一个不为空的值<br>COALESCE </p>
<p>4.(case  when pcOut.season=’1’ then ‘2’ when ….</p>
<p>5.substring()</p>
<p>6.Round(double,2) 四舍五入到指定位数的</p>
<p>7.日期函数 <br><br>date_ForMate(,’%Y-%m_%d’);<br>UNiX_TIMESTAMP(create_date)<br>str_to_date()<br>datetime类型的比较大小<br>unix_timestamp(time1) &gt; unix_timestamp(‘2011-03-03 17:39:05’)<br>time1 between ‘2011-03-03 17:39:05’ and ‘2011-03-03 17:39:52’;</p>
<p>8.函数自定义<br>CREATE DEFINER=<code>root</code>@<code>%</code> FUNCTION <code>countPxxclassByCreateDate</code>(createDate datetime) RETURNS int(11)<br>begin    return()  end<br>而’root’@’%’的意思是，密码正确的前提下任何人(%)都可以使用MYSQL名为’root’用户的权限，即最高管理员权限<br>9.存储过程自定义<br>CREATE DEFINER=<code>root</code>@<code>%</code> PROCEDURE <code>insert_data_proc</code>(IN v_i INT)<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>WHILE i &lt; v_i<br>DO<br>INSERT INTO my_dual VALUES (i);<br>SET i = i + 1;<br>END WHILE;<br>END</p>
<p><br><br><br><br><br><br><br></p>
<h3 id="mysql服务问题"><a href="#mysql服务问题" class="headerlink" title="mysql服务问题"></a>mysql服务问题</h3><ul>
<li>mysql server8.0 使用客客户端连接caching-sha2-password问题<br><br>
#修改加密规则  
 ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; <br>
#更新密码（mysql_native_password模式）    
 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '{NewPassword}';
centos 主机连接也是这样
ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'MyNewPass!';

</li>
</ul>
<p>centos mysql开启远程访问<br><br>1.GRANT ALL PRIVILEGES ON *.* TO ‘myuser’@’%’ IDENTIFIED BY ‘mypassword’ WITH<br>  GRANT OPTION;<br>2.FLUSH   PRIVILEGES;<br>systemctl stop firewalld.service #停止firewall<br>systemctl disable firewalld.service #禁止firewall开机启动</p>
<p><br><br><br><br><br><br><br></p>
<h3 id="mysql-索引实现机制"><a href="#mysql-索引实现机制" class="headerlink" title="mysql 索引实现机制"></a>mysql 索引实现机制</h3><p><a href="https://www.cnblogs.com/bypp/p/7755307.html" target="_blank" rel="noopener">https://www.cnblogs.com/bypp/p/7755307.html</a><br><br>索引是一种高效获取数据的存储结构，例：hash、 二叉、 红黑。<br> mysql使用的是B+tree<br><br>B+Tree只在最末端叶子节点存数据，叶子节点是以链表的形势互相指向的。<br>创建数据库表Create table user （…..），它实际是生成三个文件：<br><br>Myisam引擎<br>user.myi   索引文件     user.myd数据文件     user.frm数据结构类型。<br><br> 　　当我们执行  select * from user where id = 1的时候，它的执行流程。<br><br>　　　　(1)查看该表的myi文件有没有以id为索引的索引树。<br><br>　　　　(2)根据这个id索引找到叶子节点的id值，从而得到它里面的数据地址。(叶子节点存的是索引和数据地址)。<br><br>　　　　(3)根据数据地址去myd文件里面找到对应的数据返回出来。<br><br>数据是保存在磁盘上的，磁盘io是代价比较大，　　　　<br>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，==而是把相邻的数据也都读取到内存缓冲区内==，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<p> IO次数取决于b+数的高度h<br> 索引是B+树的数据结构。<br> 磁盘块=数据项+指针<br> 真实的数据存在于叶子节点；非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项。<br> IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。</p>
<p> 一次IO拿到一个数据块，也可以理解为拿到一个树的结点。每个数据块上有多个数据项，非叶子节点的数据项，只用来指引搜索方向，不存储真实数据。通过多次IO拿到叶子节点的时候，就可以直接在内存中，使用查找算法查找数据。因此拿到叶子节点所经历的IO次数，取决于树的高度。</p>
<p>　　　　<br>innodb引擎<br>　user.ibd   索引文件        user.frm数据结构类型<br>叶子节点存的是主键索引和数据信息)而不是地址<br>创建索引就会创建索引树<br>但是索引也不是越多越好，一方面它会占用存储空间，另一方面它会使得写操作变得很慢。通常我们对查询次数比较频繁，值比较多的列才建索引<br>使用B+树  特性 单节点存储更多数据  叶子节点形成有序链表（便于执行范围操作）<br>聚集索引中叶子节点data直接包含数据，非聚集索引，叶子节点存储数据地址的指针。</p>
<p><br><br><br><br><br><br><br></p>
<h3 id="mysql-主从复制-读写分离"><a href="#mysql-主从复制-读写分离" class="headerlink" title="mysql 主从复制 读写分离"></a>mysql 主从复制 读写分离</h3><p>MySQL主从复制（Master-Slave）与读写分离（MySQL-Proxy）实践<br>主从复制原理<br>从库生成两个线程，一个I/O线程，一个SQL线程；<br>i/o线程去请求主库 的binlog，并将得到的binlog日志写到relay log（中继日志） 文件中；主库会生成一个 log dump 线程，用来给从库 i/o线程传binlog；<br>SQL 线程，会读取relay  log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/alvin_xp/p/4162249.html</span><br><span class="line">show GLOBAL  variables LIKE &apos;%char%&apos;</span><br><span class="line">SET GLOBAL SQL_SLAVE_SKIP_COUNTER = 1; </span><br><span class="line">stop slave;</span><br><span class="line">change master to master_host=&apos;192.168.1.152&apos;,</span><br><span class="line">master_user=&apos;root&apos;,</span><br><span class="line">master_password=&apos;Nihaogyz123_&apos;,</span><br><span class="line">master_log_file=&apos;master-bin.000001&apos;,</span><br><span class="line">master_log_pos=154;</span><br><span class="line">start slave ;</span><br><span class="line">show slave status;</span><br></pre></td></tr></table></figure>

<p>问题待解决 字符集不一致导致的主从同步失败<br>‘Character set ‘#255’ is not a compiled character set and is not specified in the ‘/usr/share/mysql/charsets/Index.xml’ file’ on query. Default database: ‘nihao’. Query: ‘create<br>DATABASE nihao’</p>
<p>读写分离实现<br>两种方式<br>代码层：<br>中间件：<br>MySQL-Proxy<br>可以使用SpringAop + AbstractRoutingDataSource 实现</p>
<p>……..</p>
<h3 id="nosql"><a href="#nosql" class="headerlink" title="nosql"></a>nosql</h3><p><strong>redis</strong> value类型更加丰富 set list<br>memcached 缓存的对象不超过1M 不支持set<br>redis.properties<br>1.被缓存的类需要实现序列化接口 Serializable<br>redisUtil<br>memcached<br>memcached.properties<br>MemcacheUtil</p>
<p><strong>mongodb</strong><br>数据库–》集合–》文档<br>存储json文档<br>使用场景  网站实时场景 缓存 大尺寸低价值的数据  json<br>GridFS fs.files”和”fs.chunks”  把文件按照指定大小分割，然后存入多个文档中。  存储大文件</p>
<p><br><br><br><br><br><br><br></p>
<h3 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h3><p>步骤</p>
<ol>
<li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li>
<li>where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</li>
<li>explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</li>
<li>order by limit 形式的sql语句让排序的表优先查</li>
<li>了解业务方使用场景</li>
<li>加索引时参照建索引的几大原则</li>
<li>观察结果，不符合预期继续从0分析</li>
</ol>
<p><strong>索引问题排查</strong><br>放弃索引的情况<br>1.不同字段使用or时 转换为 union all （or 放弃使用索引）<br>show index from pos_history; 查看索引<br>2.表达式操作<br>select id from t where num/2=100<br>应改为:select id from t where num=100*2<br>3.函数操作<br>select id from t where substring(name,1,3)=’abc’–name以abc开头的id<br>select id from t where name like ‘abc%’<br>对于 like ‘..%’ (不以 % 开头)，可以应用 colunm上的index<br>4.对于连续的数值，能用 between 就不要用 in 了：<br>5.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by涉及的列上建立索引。<br>当索引列有大量数据重复时，SQL查询可能不会去利用索引</p>
<p><strong>慢查询日志查看</strong><br>/mysqldumpslow -s t -t 10 -g “left join” /log/slowquery.log<br>得到按照时间排序的前10条里面含有左连接的查询语句。</p>
<p><strong>解决order by 查询变慢的方案</strong>，<br>在排序列上添加索引，或者返回数据之后，通过coolection.Sort方法排序。</p>
<p><strong>explain查看执行计划</strong>：<br>using filesort 性能比较慢，排序字段不在驱动表里的时候，不可避免的出现了「Using filesort」，甚至「Using temporary」。<br>DEPENDENT SUBQUERY 依赖于外部记录的子查询，</p>
<p>id：id越大优先级越高，id相同从上至下。</p>
<p>table ： derived 派生表</p>
<p>type： join type 理解我访问类型 all,index,range,ref,eq_ref，const 依次增强，<br><br>all 全表扫描<br><br>index 使用所用全表扫描<br><br>range 一定是基于索引的，但同时除了显而易见的between，and以及’&gt;’,’&lt;’外，in和or也是索引范围扫描。<br><br>ref 查找条件列使用了索引而且不为主键和unique（唯一约束）<br><br>ref_eq  ref_eq 与ref相比牛的地方是，它知道这种类型的查找结果集只有一个，所以当我们首次查找到这个学号，便立即停止了查询。通常join条件如果是外键，type=eq_ref<br><br>const,通常情况下，如果将一个主键放置到where后面作为条件查询，mysql优化器就能把这次查询优化转化为一个常量。<br></p>
<p>row 循环次数 rows实际反映的是查询的内循环数，针对外层的每一条数据匹配，一枪就可以命中，rows为1。<br>column_a = 1 的记录有20条， column_a = 1 and column_b = 2 的记录有5条。那么最终查询结果应该显示5条记录。 explain结果中的rows应该是20.因为这20条记录mysql引擎必须逐行检查是否满足.所以row反映的是需要逐行检查的行数。</p>
<p>Extra 附加信息<br>Using FileSort：MySQL无法使用索引完成的排序称为”文件排序”<br>Using temporary： 使用临时表保存中间结果，在排序和分组的时候会使用<br>临时表。<br>Using Where：使用where过滤条件<br>distinct：优化distinct操作，在找到第一个匹配的元组后即停止找同样值的动作</p>
<p><br><br><br><br><br><br><br></p>
<h3 id="技巧经验"><a href="#技巧经验" class="headerlink" title="技巧经验"></a>技巧经验</h3><ol>
<li><p>straight join 就是为了替换 inner join 驱动表顺序的不可控（由mysql 优化器决定） <br></p>
</li>
<li><p>使用SQL_CACHE查询<br>对于那些变化不频繁的表，查询操作很固定，我们可以将该查询操作缓存起来，这样每次执行的时候不实际访问表和执行查询，只是从缓存获得结果，可以有效地改善查询的性能，使用SQL_CACHE 选项<br><br>测试sql语句性能使用SQl_NO_CACHE </p>
</li>
<li><p>delete 数据的时候一定要注意。小心把整张表都删除  例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 删除后补记录数据 --&gt;</span><br><span class="line">    &lt;delete id=&quot;deleteSignupCandidate&quot;&gt;</span><br><span class="line">        delete from signup_candidate_info where 1=1</span><br><span class="line">        &lt;choose&gt;</span><br><span class="line">            &lt;when test=&quot;ids != null and ids != &apos;&apos;&quot;&gt;</span><br><span class="line">                AND id in</span><br><span class="line">                &lt;foreach collection=&quot;ids.split(&apos;,&apos;)&quot; item=&quot;item&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">                    #&#123;item&#125;</span><br><span class="line">                &lt;/foreach&gt;</span><br><span class="line">            &lt;/when&gt;</span><br><span class="line">            &lt;otherwise&gt;</span><br><span class="line">                AND 1=2</span><br><span class="line">            &lt;/otherwise&gt;</span><br><span class="line">        &lt;/choose&gt;</span><br><span class="line">    &lt;/delete&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CONVERT ( trim( a.NAME ) USING gbk ) 按照中文拼音排序， 但是会导致索引失效。</p>
</li>
<li><p>in () 中值很多的时候，mysql优化器会认为全表扫描速度优于索引，如果和事实相反，可以使用force  index 强制索引。 </p>
</li>
<li><p>数据库设计阶段，不一定一定要严格按照三范式，大表需要经常关联的join数据可以字段冗余，一般就业务逻辑而言，生成一次一般就不会再修改了，但是在查询的时候需要经常查询，那么可以做数据冗余，满足第二范式即可。以空间换时间。</p>
</li>
<li><p>如果业务上需要按照中文姓名排序分页，可以增加姓名拼音字段。因为使用mysql函数，需要转utf8编码为gbk，而且不能使用索引。排序会很慢。</p>
</li>
<li><p>系统在分页的情况下，使用子查询可能比表连接性能高。对于没有分页的数据还是要优秀考虑 （需要考虑在什么情况下会先执行limit 后执行 子查询？？？？？？？？）</p>
</li>
<li><p>left join 并不一定是左边的表是驱动表，而STRAIGHT_JOIN一定是左边的表是驱动表</p>
</li>
<li><p>在find_in_set 不能使用索引的情况下，可以考虑通过代码转换为in查询</p>
</li>
</ol>
<p><br><br><br><br><br><br><br></p>
<h3 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h3><p><strong>概念：</strong><br>域 笛卡尔积 关系（笛卡尔积的子集，不能重复）<br>用户自定义完整性（对数据的具体语义要求）</p>
<p><strong>关系运算：</strong><br>选择运算：条件筛选（针对行）<br>投影运算：针对列 取消原关系中的某些列<br>连接运算：======<br>等值连接 ：判断条件为等号的连接运算称为等值连接<br>自然连接: 特殊的等值连接，两个关系中进行比较的分量必须是相同的属性组，重复属性组去掉一列  （公共属性列必须都相同）<br>除运算：<br>象集：关系：姓名x 课程z    Z张军=物理，数学，<br>除法：首先有公共列，商是非公共列。<br>先看非公共列的不同元素的对应的象 是否包含除数的某一行</p>
<p><strong>第三章</strong><br>创建  create database table view/index（索引）<br>View和index 不能更改<br>Createtable  teblename （<br>CustId varchar（5） primarykey （完整性约束：not null，unique，check（取值需要满足的条件，default））<br>）<br><strong>级联更新</strong>：在更新在级联更新中，更新所有外键值以与新的主键值相匹配。<br>修改表<br>Alter table  alter column varchar（）<br>Alter table  add  column varchar（100） 、、添加列<br>Alter table  add constraint  DF_custCity Default ‘beijing’ for custcity //为某一列添加约束<br>删除约束用drop   constraint DF_custCity；<br>删除表 drop table 没有被引用的时候才能删除<br><br><strong>索引</strong>的建立和删除：主要目的加快查询速度 <br><br>代价：增加存储空间 插入和修改的时候也要同时修改索引 浪费时间<br>建立索引的原则：<br>经常需要搜索的列上，主键列，外键列，排序列（因为索引已经排序好了） 经常where 判断列，加快条件判断速度。<br>不建索引的原则：数值很少 text image bit<br>Create index on table &lt;列名&gt;<br>索引分类   unique索引 聚集索引（键值逻辑顺序和物理顺序一致）    </p>
<p>Insert into tablename（列名） values<br>Delete from tablename where<br>Update tablename set 列名=‘’where 条件<br>级联更新：更新语句一次只能操作一个表，可能配合事物处理才能级联<br>Sql 查询<br>Select from where group by having &lt;条件表达式&gt; order by  将符合having条件表达式的结果放到group 结果中。<br>简单查询：between  like   %代表任意长度字符    _代表任意单个字符<br>Notlike   转义字符  is null    in 集合<br>Select  top 2  from<br>top 和 order by一起使用<br>集合运算：<br>union 运算 （并集）<br>intersect （交集）<br>差运算 except<br>如果进行了集合运算 Order by 只能放到最后。 </p>
<p><strong>连接查询</strong>：<br>一般连接  根据公共属性列值相同的连接起来<br>select from table a ，b where a.lie=b.lie;<br>内连接：<br>select * from custom inner join orders on =  where<br>特列：和自身进行连接，通过别名实现<br>select ca.* from custom ca ,customc cb,where ca.=cb. and cb.custom=’’;<br>外连接<br>与普通连接区别 外连接有连接主体 主体表中不满足连接条件的元祖一并输出<br>left join   right join<br>不满足条件的元组新增属性列可能为空。</p>
<p><strong>分组和汇总</strong><br>group by 后可以跟的聚合函数<br>count（<em>）元组个数  加distinct 可以在统计count</em>的时候去掉重复的值<br>count&lt;列名&gt; 计算一列值的个数 select count（distinct custCity） as newname<br>sum avg max min 、</p>
<p><strong>嵌套查询：</strong><br><strong>内外层不相关的运算</strong><br>子查询只是一个中间集 不能用order by语句<br>select custID from Orders where orderid =（select orderid from 。。。。。）<br>等于号可以换成 in  等于号要确定是单值才可以用<br>同理大于小于号也需要子查询返回为单值<br>若返回为多值 配合使用ALL ANY 等谓词 where price&gt;all (select …)  也可以使用聚合函数<br><strong>内外层相关的运算</strong>（子查询的查询条件where 依赖于父查询）<br>select * from order a where orderAmount=（select form ordder b where a.custid=b.custid）</p>
<p>exists 返回真假</p>
<p>需要查询支持的操作<br>插入结果集 修改操作 删除操作  in / not in是否在子查询返回的结果集中</p>
<p><strong>视图</strong><br>定义  虚表<br>create view name  as select 。。。。。。<br>with check option<br>视图不存储数据  最终也要转换为对基本表的查询<br>视图有的更新<br>定义了视图的好处<br>让用户能够着重于他们感兴趣的特定数据和所负责的特定任务。<br>只能看到视图中的数据   增加了安全性<br>简化用户操作</p>
<p>数据库设计<br>规范化理论 好的关系模式<br>数据冗余问题 操作异常问题<br>问题提出<br>订单表和商品表 数据冗余问题 （一个订单包含三个商品）<br>好的关系模式 数据冗余尽可能的少 避免出现更新异常<br>解决方法：模式分解，分解成小的关系模式 </p>
<p>函数依赖<br>最小函数依赖集</p>
<p>订购关系模式中<br>orderid-&gt;（orderdate 。orderadress）</p>
<p>传递函数依赖 弱数据依赖  产生数据冗余的原因之一</p>
<p>码：决定元组<br>超码：k-&gt;U(一个元组)，k称为关系模式R（U，F）的超码<br>候选码：k完全依赖U 去掉k中的一个属性就不能完全决定一个元组<br>主码：多个候选码中选一个作为主码</p>
<p>求最小函数依赖集<br>R(U,F) U=ABC F={A-&gt;BC,B-&gt;C,AB-&gt;C}<br>1 右部单属性化F={A-&gt;B,A-&gt;C,B-&gt;C,AB-&gt;C}<br>2 去掉多余的函数依赖F={A-&gt;B,B-&gt;C}</p>
<p><strong>规范化 **<br>**范式</strong>：1 2 3 BC 4 5<br>范式级别越高 条件越多<br>通过模式分解可以转换为若干个高一级范式的关系模式集合<br>1NF 属性值不可分  域值不可分  比如两个电话号码  解决方法 纵横延伸<br>2NF  所有的非主属性都完全依赖于R的码 解决方法：投影分解<br> 消除了由部分依赖带来的数据冗余和操作异常问题<br>2NF中有传递依赖<br><strong>3NF</strong> 非主属性都不传递依赖于码 消除由传递函数依赖带来的数据冗余 （例如为了提高查询性能的情况下，可以降低范式）<br>BCNF   针对于1NF 来说的  R属于1NF 对任何非平凡的函数依赖X-&gt;Y X均包含码，则R属于BCNF<br>BCNF一定是3NF  反之不一定成立<br>3NF 升级到BC范式 消除的是主属性对不包含她的码的部分依赖和传递依赖</p>
<p><strong>事务的特性：</strong><br>原子性，全部回滚<br>一致性，AB转账钱的总数不变<br>隔离性，并发事务感觉不到对方的存在<br>持久性：只要事物提交就一定会持久化到数据库</p>
<p>并发访问容易产生的问题：<br>脏读，一事务读取了另一个事务未提交的脏数据，回滚之前读取的。<br>不可重复读，读取了前一事务提交的数据。<br>幻读，修改1到2 到新插入了一条1，以为出现了幻觉</p>
<p><strong>隔离级别</strong>  （级别越高执行效率越低）由低到高 ：<br>读未提交：<br>读已提交 ：避免脏读<br>可重复读：避免脏读，可重复读 mysql 默认<br>串行化：避免所有问题</p>
<p><strong>事务传播机制</strong> （一个事务中嵌套着另一个事务）<br>事务的第一个方面是传播行为（propagation behavior）。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring定义了七种传播行为：</p>
<p>DDL 语句 （数据定义语言）<br><br>包括对database table view  PROCEDURE的创建删除<br><br>mysql8.0之后 DDL原子化<br><br>例如，库里只有一个t1表，drop table t1,t2;<br> 试图删除t1,t2两张表,在5.7中，执行报错，但是t1表被删除，在8.0中执行报错，但是t1表没有被删除，证明了8.0 DDL操作的原子性，要么全部成功，要么回滚。<br></p>
<p><strong>mysql 定义用户变量 实现递增或者查询排序</strong><br><br>set @name = ‘’;<br>select @name:=password from user limit 0,1;<br>set @ageinit=23;<br>update t_user<br>SET age = (<br>select @ageinit:= @ageinit +1 as nid<br>对用户变量赋值有两种方式，一种是直接用”=”号，另一种是用”:=”号。其区别在于使用set命令对用户变量进行赋值时，两种方式都可以使用；当使用select语句对用户变量进行赋值时，只能使用”:=”方式，因为在select语句中，”=”号declare语句专门用于定义局部变量。set语句是设置不同类型的变量，包括会话变量和全局变量。</p>
<p><strong>子查询运算符号</strong><br><br>ALL ANY EXISTS<br><br>–ALL运算符<br><br>　　和子查询的结果逐一比较，必须全部满足时表达式的值才为真。<br><br>–ANY运算符<br><br>　　和子查询的结果逐一比较，其中一条记录满足条件则表达式的值就为真。<br><br>–EXISTS/NOT EXISTS运算符<br><br>　　EXISTS判断子查询是否存在数据，如果存在则表达式为真，反之为假。NOT EXISTS相反。</p>
</div><div class="post-copyright"><blockquote><p>Original author: John Doe</p><p>Original link: <a href="http://yoursite.com/2019/08/09/mysql/">http://yoursite.com/2019/08/09/mysql/</a></p><p>Copyright Notice: Please indicate the source of the reprint (must retain the author's signature and link)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>Share:</span></div></div><div class="post-nav"><a href="/2019/08/08/my-first-blog/" class="next">my-first-blog</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql-相关"><span class="toc-text">mysql 相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql复杂查询总结"><span class="toc-text">mysql复杂查询总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql常用函数"><span class="toc-text">Mysql常用函数 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql服务问题"><span class="toc-text">mysql服务问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql-索引实现机制"><span class="toc-text">mysql 索引实现机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql-主从复制-读写分离"><span class="toc-text">mysql 主从复制 读写分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nosql"><span class="toc-text">nosql</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#慢查询优化"><span class="toc-text">慢查询优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#技巧经验"><span class="toc-text">技巧经验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库基础"><span class="toc-text">数据库基础</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/09/mysql/">mysql</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/08/my-first-blog/">my-first-blog</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/08/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/技术/" style="font-size: 15px;">技术</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">John Doe.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>